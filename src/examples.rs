use crate::config::{
    Config, default_http_auth_config_for_examples, default_s3_storage_config_for_examples,
};
use std::{
    collections::{BTreeMap, BTreeSet},
    fs,
    path::{Path, PathBuf},
};

const ENV_EXAMPLE_FILE: &str = ".env.example";
const CONFIG_EXAMPLE_FILE: &str = "config.example.yml";

pub fn sync_example_files(repo_root: &Path) -> Result<(), String> {
    let env_example = render_env_example(repo_root)?;
    write_if_changed(&repo_root.join(ENV_EXAMPLE_FILE), &env_example)?;

    let config_example = render_config_example();
    write_if_changed(&repo_root.join(CONFIG_EXAMPLE_FILE), &config_example)?;
    Ok(())
}

pub fn render_env_example(repo_root: &Path) -> Result<String, String> {
    let vars = discover_env_vars(repo_root)?;
    let defaults = env_defaults();
    let mut lines = vec![
        "# Auto-generated by `cargo run --bin sync_examples`.".to_string(),
        "# Keep this file in sync with environment variables used by rustaccio.".to_string(),
        "".to_string(),
    ];

    for var in vars {
        let value = defaults.get(var.as_str()).copied().unwrap_or("");
        lines.push(format!("{var}={value}"));
    }

    lines.push(String::new());
    Ok(lines.join("\n"))
}

pub fn render_config_example() -> String {
    let cfg = Config::defaults_for_examples();
    let auth_http = default_http_auth_config_for_examples();
    let s3 = default_s3_storage_config_for_examples();

    format!(
        r#"listen:
  - {bind}

storage: {data_dir}

uplinks:
  npmjs:
    url: https://registry.npmjs.org/

packages:
  "@*/*":
    access: $all
    publish: $authenticated
    unpublish: $authenticated
    proxy: npmjs
    uplinksLook: true
  "**":
    access: $all
    publish: $authenticated
    unpublish: $authenticated
    proxy: npmjs
    uplinksLook: true

web:
  enable: {web_enabled}
  title: {web_title}

flags:
  webLogin: {web_login}

publish:
  check_owners: {publish_check_owners}

middlewares:
  audit:
    enabled: {audit_enabled}

max_body_size: {max_body_size_mb}mb
url_prefix: {url_prefix}

server:
  # keepAliveTimeout: 60
  # Any trustProxy value enables trusted proxy mode.
  # trustProxy: true

log:
  level: {log_level}

auth:
  backend: local
  external: false
  # backend: http
  # http:
  #   baseUrl: http://127.0.0.1:9000
  #   addUserEndpoint: {http_adduser}
  #   loginEndpoint: {http_login}
  #   changePasswordEndpoint: {http_change_password}
  #   requestAuthEndpoint: /request-auth
  #   allowAccessEndpoint: /allow-access
  #   allowPublishEndpoint: /allow-publish
  #   allowUnpublishEndpoint: /allow-unpublish
  #   timeoutMs: {http_timeout_ms}

store:
  backend: local
  # backend: s3
  # s3:
  #   bucket: npm-cache
  #   region: {s3_region}
  #   endpoint: http://127.0.0.1:9001
  #   accessKeyId: minio
  #   secretAccessKey: miniopass
  #   prefix: {s3_prefix}
  #   forcePathStyle: {s3_force_path_style}
"#,
        bind = cfg.bind,
        data_dir = cfg.data_dir.display(),
        web_enabled = cfg.web_enabled,
        web_title = cfg.web_title,
        web_login = cfg.web_login,
        publish_check_owners = cfg.publish_check_owners,
        audit_enabled = cfg.audit_enabled,
        max_body_size_mb = cfg.max_body_size / (1024 * 1024),
        url_prefix = cfg.url_prefix,
        log_level = cfg.log_level,
        http_adduser = auth_http.add_user_endpoint,
        http_login = auth_http.login_endpoint,
        http_change_password = auth_http.change_password_endpoint,
        http_timeout_ms = auth_http.timeout_ms,
        s3_region = s3.region,
        s3_prefix = s3.prefix,
        s3_force_path_style = s3.force_path_style,
    )
}

pub fn discover_env_vars(repo_root: &Path) -> Result<BTreeSet<String>, String> {
    let mut vars = BTreeSet::new();
    let src_dir = repo_root.join("src");
    collect_env_vars_in_dir(&src_dir, &mut vars)?;
    vars.insert("RUST_LOG".to_string());
    Ok(vars)
}

fn collect_env_vars_in_dir(dir: &Path, vars: &mut BTreeSet<String>) -> Result<(), String> {
    let entries = fs::read_dir(dir).map_err(|err| format!("failed to read {dir:?}: {err}"))?;
    for entry in entries {
        let entry = entry.map_err(|err| format!("failed to read entry in {dir:?}: {err}"))?;
        let path = entry.path();
        let file_type = entry
            .file_type()
            .map_err(|err| format!("failed file_type for {path:?}: {err}"))?;
        if file_type.is_dir() {
            collect_env_vars_in_dir(&path, vars)?;
            continue;
        }
        if path.extension().and_then(|ext| ext.to_str()) != Some("rs") {
            continue;
        }
        let text = fs::read_to_string(&path)
            .map_err(|err| format!("failed to read source file {path:?}: {err}"))?;
        extract_env_vars_from_source(&text, vars);
    }
    Ok(())
}

fn extract_env_vars_from_source(source: &str, vars: &mut BTreeSet<String>) {
    let bytes = source.as_bytes();
    let marker = b"RUSTACCIO_";
    let mut i = 0usize;
    while i + marker.len() <= bytes.len() {
        if &bytes[i..i + marker.len()] == marker {
            let mut end = i + marker.len();
            while end < bytes.len() {
                let c = bytes[end] as char;
                if c.is_ascii_uppercase() || c.is_ascii_digit() || c == '_' {
                    end += 1;
                } else {
                    break;
                }
            }
            if end > i + marker.len() {
                vars.insert(source[i..end].to_string());
            }
            i = end;
        } else {
            i += 1;
        }
    }
}

fn env_defaults() -> BTreeMap<&'static str, &'static str> {
    BTreeMap::from([
        ("RUSTACCIO_ADMIN_ALLOW_ANY_AUTHENTICATED", "true"),
        ("RUSTACCIO_ADMIN_GROUPS", ""),
        ("RUSTACCIO_ADMIN_USERS", ""),
        ("RUSTACCIO_AUDIT_ENABLED", "true"),
        ("RUSTACCIO_AUTH_BACKEND", "local"),
        ("RUSTACCIO_AUTH_EXTERNAL_MODE", "false"),
        ("RUSTACCIO_AUTH_HTTP_ADDUSER_ENDPOINT", "/adduser"),
        (
            "RUSTACCIO_AUTH_HTTP_CHANGE_PASSWORD_ENDPOINT",
            "/change-password",
        ),
        ("RUSTACCIO_AUTH_HTTP_LOGIN_ENDPOINT", "/authenticate"),
        ("RUSTACCIO_AUTH_HTTP_TIMEOUT_MS", "5000"),
        ("RUSTACCIO_BIND", "127.0.0.1:4873"),
        ("RUSTACCIO_CONFIG_BASE64", ""),
        ("RUSTACCIO_DATA_DIR", ".rustaccio-data"),
        ("RUSTACCIO_KEEP_ALIVE_TIMEOUT", ""),
        ("RUSTACCIO_LOG_FORMAT", "pretty"),
        ("RUSTACCIO_LOG_LEVEL", "info"),
        ("RUSTACCIO_LOGIN_SESSION_TTL_SECONDS", "120"),
        ("RUSTACCIO_MAX_BODY_SIZE", "50mb"),
        ("RUSTACCIO_METRICS_BACKEND", "none"),
        ("RUSTACCIO_METRICS_PATH", "/-/metrics"),
        ("RUSTACCIO_METRICS_REQUIRE_ADMIN", "true"),
        ("RUSTACCIO_OTEL_ENABLED", "false"),
        ("RUSTACCIO_OTEL_EXPORTER_OTLP_ENDPOINT", ""),
        ("RUSTACCIO_OTEL_SERVICE_NAME", "rustaccio"),
        ("RUSTACCIO_PASSWORD_MIN", "3"),
        ("RUSTACCIO_SAAS_MODE", "false"),
        ("RUSTACCIO_POLICY_BACKEND", "local"),
        ("RUSTACCIO_POLICY_HTTP_BASE_URL", ""),
        ("RUSTACCIO_POLICY_HTTP_CACHE_TTL_MS", "5000"),
        ("RUSTACCIO_POLICY_HTTP_DECISION_ENDPOINT", "/authorize"),
        ("RUSTACCIO_POLICY_HTTP_FAIL_OPEN", "false"),
        ("RUSTACCIO_POLICY_HTTP_TIMEOUT_MS", "3000"),
        ("RUSTACCIO_QUOTA_BACKEND", "none"),
        ("RUSTACCIO_QUOTA_DOWNLOADS_PER_DAY", "0"),
        ("RUSTACCIO_QUOTA_FAIL_OPEN", "true"),
        ("RUSTACCIO_QUOTA_POSTGRES_URL", ""),
        ("RUSTACCIO_QUOTA_PUBLISHES_PER_DAY", "0"),
        ("RUSTACCIO_QUOTA_REQUESTS_PER_DAY", "0"),
        ("RUSTACCIO_RATE_LIMIT_BACKEND", "none"),
        ("RUSTACCIO_RATE_LIMIT_FAIL_OPEN", "true"),
        ("RUSTACCIO_RATE_LIMIT_REDIS_URL", ""),
        ("RUSTACCIO_RATE_LIMIT_REQUESTS_PER_WINDOW", "0"),
        ("RUSTACCIO_RATE_LIMIT_WINDOW_SECS", "60"),
        ("RUSTACCIO_PUBLISH_CHECK_OWNERS", "false"),
        ("RUSTACCIO_REQUEST_TIMEOUT_SECS", "30"),
        ("RUSTACCIO_S3_CA_BUNDLE", ""),
        ("RUSTACCIO_S3_FORCE_PATH_STYLE", "true"),
        ("RUSTACCIO_S3_PREFIX", ""),
        ("RUSTACCIO_S3_REGION", "us-east-1"),
        ("RUSTACCIO_TARBALL_BACKEND", "local"),
        ("RUSTACCIO_TOKIO_MAX_BLOCKING_THREADS", "64"),
        ("RUSTACCIO_TOKIO_THREAD_STACK_SIZE", "1048576"),
        ("RUSTACCIO_TRUST_PROXY", "false"),
        ("RUSTACCIO_UPSTREAM_CONNECT_TIMEOUT_SECS", "3"),
        ("RUSTACCIO_UPSTREAM_POOL_IDLE_TIMEOUT_SECS", "30"),
        ("RUSTACCIO_UPSTREAM_POOL_MAX_IDLE_PER_HOST", "4"),
        ("RUSTACCIO_UPSTREAM_TCP_KEEPALIVE_SECS", "30"),
        ("RUSTACCIO_UPSTREAM_TIMEOUT_SECS", "20"),
        ("RUSTACCIO_URL_PREFIX", "/"),
        ("RUSTACCIO_VERBOSE_DEP_LOGS", "false"),
        ("RUSTACCIO_WEB_ENABLE", "true"),
        ("RUSTACCIO_WEB_LOGIN", "false"),
        ("RUSTACCIO_WEB_TITLE", "Rustaccio"),
    ])
}

fn write_if_changed(path: &PathBuf, content: &str) -> Result<(), String> {
    let current = fs::read_to_string(path).unwrap_or_default();
    if current == content {
        return Ok(());
    }
    fs::write(path, content).map_err(|err| format!("failed to write {}: {err}", path.display()))
}
